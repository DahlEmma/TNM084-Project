{
  "version": 3,
  "sources": ["../three/examples/jsm/postprocessing/OutlinePass.js"],
  "sourcesContent": ["import {\n\tAdditiveBlending,\n\tColor,\n\tDoubleSide,\n\tLinearFilter,\n\tMatrix4,\n\tMeshBasicMaterial,\n\tMeshDepthMaterial,\n\tNoBlending,\n\tRGBADepthPacking,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nclass OutlinePass extends Pass {\n\n\tconstructor( resolution, scene, camera, selectedObjects ) {\n\n\t\tsuper();\n\n\t\tthis.renderScene = scene;\n\t\tthis.renderCamera = camera;\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\t\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\n\t\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\n\t\tthis.edgeGlow = 0.0;\n\t\tthis.usePatternTexture = false;\n\t\tthis.edgeThickness = 1.0;\n\t\tthis.edgeStrength = 3.0;\n\t\tthis.downSampleRatio = 2;\n\t\tthis.pulsePeriod = 0;\n\n\t\tthis._visibilityCache = new Map();\n\n\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\n\t\tconst resx = Math.round( this.resolution.x / this.downSampleRatio );\n\t\tconst resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\t\tthis.maskBufferMaterial = new MeshBasicMaterial( { color: 0xffffff } );\n\t\tthis.maskBufferMaterial.side = DoubleSide;\n\t\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\n\t\tthis.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\t\tthis.depthMaterial = new MeshDepthMaterial();\n\t\tthis.depthMaterial.side = DoubleSide;\n\t\tthis.depthMaterial.depthPacking = RGBADepthPacking;\n\t\tthis.depthMaterial.blending = NoBlending;\n\n\t\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\t\tthis.prepareMaskMaterial.side = DoubleSide;\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\t\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\n\t\tthis.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\n\t\tthis.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\t\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\t\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\n\t\tthis.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\t\tconst MAX_EDGE_THICKNESS = 4;\n\t\tconst MAX_EDGE_GLOW = 4;\n\n\t\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;\n\t\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;\n\n\t\t// Overlay material\n\t\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t\t// copy material\n\t\tif ( CopyShader === undefined ) console.error( 'THREE.OutlinePass relies on CopyShader' );\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t\tthis.tempPulseColor1 = new Color();\n\t\tthis.tempPulseColor2 = new Color();\n\t\tthis.textureMatrix = new Matrix4();\n\n\t\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\t\tvar type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\t\tthis.renderTargetDepthBuffer.setSize( width, height );\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t}\n\n\tchangeVisibilityOfSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t}\n\n\tchangeVisibilityOfNonSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\t\tconst selectedMeshes = [];\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) selectedMeshes.push( object );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\t\t// only meshes and sprites are supported by OutlinePass\n\n\t\t\t\tlet bFound = false;\n\n\t\t\t\tfor ( let i = 0; i < selectedMeshes.length; i ++ ) {\n\n\t\t\t\t\tconst selectedObjectId = selectedMeshes[ i ].id;\n\n\t\t\t\t\tif ( selectedObjectId === object.id ) {\n\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( bFound === false ) {\n\n\t\t\t\t\tconst visibility = object.visible;\n\n\t\t\t\t\tif ( bVisible === false || cache.get( object ) === true ) {\n\n\t\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcache.set( object, visibility );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints || object.isLine ) {\n\n\t\t\t\t// the visibilty of points and lines is always set to false in order to\n\t\t\t\t// not affect the outline computation\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object ); // restore\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t}\n\n\tupdateTextureMatrix() {\n\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tconst oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis.changeVisibilityOfSelectedObjects( false );\n\n\t\t\tconst currentBackground = this.renderScene.background;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t// Make selected objects visible\n\t\t\tthis.changeVisibilityOfSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis.updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( false );\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\tthis.renderScene.overrideMaterial = null;\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\tconst scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis.fsQuad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis.fsQuad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;\n\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\tgetPrepareMaskMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'depthTexture': { value: null },\n\t\t\t\t'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'textureMatrix': { value: null }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t}\n\n\tgetEdgeDetectionMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetSeperableBlurMaterial( maxRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'MAX_RADIUS': maxRadius,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'kernelRadius': { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetOverlayMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'edgeTexture1': { value: null },\n\t\t\t\t'edgeTexture2': { value: null },\n\t\t\t\t'patternTexture': { value: null },\n\t\t\t\t'edgeStrength': { value: 1.0 },\n\t\t\t\t'edgeGlow': { value: 1.0 },\n\t\t\t\t'usePatternTexture': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t}\n\n}\n\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { OutlinePass };\n"],
  "mappings": "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",
  "names": []
}
